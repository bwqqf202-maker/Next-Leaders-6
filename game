import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, RotateCcw, Volume2, Trophy, Heart, Activity, Ghost, User, Zap } from 'lucide-react';

// --- Constants & Config ---
const LANES = ['D', 'F', 'J', 'K'];
// 各レーンの色定義（キャラクターの色分けに使用）
const LANE_COLORS = [
  'text-cyan-400 drop-shadow-[0_0_10px_rgba(34,211,238,0.8)]',
  'text-fuchsia-400 drop-shadow-[0_0_10px_rgba(232,121,249,0.8)]',
  'text-yellow-400 drop-shadow-[0_0_10px_rgba(250,204,21,0.8)]',
  'text-green-400 drop-shadow-[0_0_10px_rgba(74,222,128,0.8)]'
];
const HIT_Y = 520; // 判定ラインのY座標
const SPAWN_Y = -50;
const SPEED = 6; // 落下速度
const JUDGEMENT_ZONES = {
  PERFECT: 40,
  GOOD: 80,
  MISS: 120,
};

// --- Audio Engine (Web Audio API) ---
class AudioEngine {
  ctx: AudioContext | null = null;
  gainNode: GainNode | null = null;

  init() {
    if (!this.ctx) {
      this.ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
      this.gainNode = this.ctx.createGain();
      this.gainNode.connect(this.ctx.destination);
      this.gainNode.gain.value = 0.3; // Master volume
    }
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
  }

  playTone(freq: number, type: 'sine' | 'square' | 'sawtooth' | 'triangle', duration: number, vol: number = 1) {
    if (!this.ctx || !this.gainNode) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.type = type;
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

    osc.connect(gain);
    gain.connect(this.gainNode);
    
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }

  playKick() {
    this.playTone(150, 'square', 0.1, 1.2);
    this.playTone(60, 'sine', 0.2, 1.5);
  }

  playSnare() {
    this.playTone(400, 'triangle', 0.1, 0.8);
  }

  playMelody(noteIndex: number) {
    const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; 
    const freq = scale[noteIndex % scale.length];
    this.playTone(freq, 'sine', 0.3, 0.6);
  }
}

const audio = new AudioEngine();

// --- Components ---

export default function NeonRhythmApp() {
  // Game State
  const [gameState, setGameState] = useState<'MENU' | 'PLAYING' | 'GAMEOVER'>('MENU');
  const [score, setScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [health, setHealth] = useState(100);
  const [judgeText, setJudgeText] = useState<{ text: string, color: string, id: number } | null>(null);
  const [characterAction, setCharacterAction] = useState<'IDLE' | 'ATTACK' | 'DAMAGE'>('IDLE');
  
  // Frame Trigger for React Re-render
  const [, setTick] = useState(0);

  // Refs for Game Loop
  const requestRef = useRef<number>();
  const notesRef = useRef<any[]>([]); 
  const nextNoteTimeRef = useRef<number>(0);
  const startTimeRef = useRef<number>(0);
  const scoreRef = useRef(0);
  const comboRef = useRef(0);
  const healthRef = useRef(100);
  const gameStateRef = useRef<'MENU' | 'PLAYING' | 'GAMEOVER'>('MENU');
  
  const [activeLanes, setActiveLanes] = useState<boolean[]>([false, false, false, false]);

  // --- Game Loop Logic ---

  const spawnNote = (timestamp: number) => {
    const timeSinceStart = timestamp - startTimeRef.current;
    
    if (timeSinceStart > nextNoteTimeRef.current) {
      const lane = Math.floor(Math.random() * 4);
      const type = Math.random() > 0.7 ? 'MELODY' : 'BEAT';
      
      notesRef.current.push({
        id: Math.random().toString(36).substr(2, 9),
        lane: lane,
        y: SPAWN_Y,
        type: type,
        hit: false,
        // ノーツごとに微妙に異なるキャラ画像を割り当てることも可能
        // image: 'path/to/enemy.png' 
      });

      // Difficulty logic
      const difficultyMultiplier = Math.min(timeSinceStart / 60000, 0.6); 
      const baseInterval = 600; 
      nextNoteTimeRef.current = timeSinceStart + (baseInterval - (baseInterval * difficultyMultiplier));
    }
  };

  const update = useCallback((timestamp: number) => {
    if (gameStateRef.current !== 'PLAYING') return;

    // 1. Spawn Notes
    spawnNote(timestamp);

    // 2. Move Notes
    notesRef.current.forEach(note => {
      note.y += SPEED;
    });

    // 3. Check Misses
    const missedNotes = notesRef.current.filter(n => n.y > HIT_Y + JUDGEMENT_ZONES.MISS && !n.hit);
    if (missedNotes.length > 0) {
      missedNotes.forEach(() => {
        handleMiss();
      });
      notesRef.current = notesRef.current.filter(n => n.y <= HIT_Y + JUDGEMENT_ZONES.MISS || n.hit);
    }

    // 4. Cleanup Hit Notes
    notesRef.current = notesRef.current.filter(n => !n.hit);

    // 5. Game Over Check
    if (healthRef.current <= 0) {
      endGame();
      return;
    }

    // 6. Force React Re-render
    setTick(prev => prev + 1);

    requestRef.current = requestAnimationFrame(update);
  }, []);

  const handleMiss = () => {
    comboRef.current = 0;
    setCombo(0);
    healthRef.current = Math.max(0, healthRef.current - 15);
    setHealth(healthRef.current);
    showJudgement('MISS', 'text-gray-500');
    
    // キャラクターリアクション：ダメージ
    setCharacterAction('DAMAGE');
    setTimeout(() => setCharacterAction('IDLE'), 300);
  };

  const showJudgement = (text: string, color: string) => {
    setJudgeText({ text, color, id: Date.now() });
    setTimeout(() => setJudgeText(null), 500);
  };

  const endGame = () => {
    gameStateRef.current = 'GAMEOVER';
    setGameState('GAMEOVER');
    if (requestRef.current) cancelAnimationFrame(requestRef.current);
    setMaxCombo(prev => Math.max(comboRef.current, prev));
  };

  const startGame = () => {
    audio.init(); 
    
    setScore(0);
    setCombo(0);
    setHealth(100);
    setJudgeText(null);
    setGameState('PLAYING');
    setCharacterAction('IDLE');
    
    notesRef.current = [];
    scoreRef.current = 0;
    comboRef.current = 0;
    healthRef.current = 100;
    nextNoteTimeRef.current = 0;
    startTimeRef.current = performance.now();
    gameStateRef.current = 'PLAYING';
    
    if (requestRef.current) cancelAnimationFrame(requestRef.current);
    requestRef.current = requestAnimationFrame(update);
  };

  // --- Input Handling ---

  const handleInput = (laneIndex: number) => {
    if (gameStateRef.current !== 'PLAYING') return;

    // Visual & Audio
    const newLanes = [...activeLanes];
    newLanes[laneIndex] = true;
    setActiveLanes(newLanes);
    setTimeout(() => {
      setActiveLanes(prev => {
        const reset = [...prev];
        reset[laneIndex] = false;
        return reset;
      });
    }, 100);

    audio.playKick();

    // Collision Logic
    const laneNotes = notesRef.current.filter(n => n.lane === laneIndex && !n.hit);
    if (laneNotes.length === 0) return;

    laneNotes.sort((a, b) => b.y - a.y);
    const targetNote = laneNotes[0];
    const distance = Math.abs(targetNote.y - HIT_Y);

    if (distance < JUDGEMENT_ZONES.MISS) {
      targetNote.hit = true;
      let points = 0;
      let judgement = '';
      let color = '';

      if (distance < JUDGEMENT_ZONES.PERFECT) {
        judgement = 'PERFECT';
        color = 'text-yellow-400 drop-shadow-[0_0_10px_rgba(250,204,21,0.8)]';
        points = 100;
        healthRef.current = Math.min(100, healthRef.current + 2);
        audio.playMelody(comboRef.current);
      } else if (distance < JUDGEMENT_ZONES.GOOD) {
        judgement = 'GOOD';
        color = 'text-green-400';
        points = 50;
        healthRef.current = Math.min(100, healthRef.current + 1);
        audio.playSnare();
      } else {
        judgement = 'BAD';
        color = 'text-blue-400';
        points = 10;
        comboRef.current = 0; 
      }

      if (judgement !== 'BAD') {
        comboRef.current += 1;
        // キャラクターリアクション：攻撃（成功）
        setCharacterAction('ATTACK');
        setTimeout(() => setCharacterAction('IDLE'), 150);
      } else {
        setCombo(0);
      }

      scoreRef.current += points + (comboRef.current * 10);
      
      setScore(scoreRef.current);
      setCombo(comboRef.current);
      setHealth(healthRef.current);
      showJudgement(judgement, color);
    }
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.repeat) return;
      const keyIndex = LANES.indexOf(e.key.toUpperCase());
      if (keyIndex !== -1) {
        handleInput(keyIndex);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  useEffect(() => {
    return () => {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, []);

  return (
    <div className="w-full h-screen bg-slate-900 text-white overflow-hidden font-sans select-none flex flex-col items-center justify-center relative touch-manipulation">
      
      {/* Background Ambience */}
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-indigo-900 via-slate-900 to-black z-0 pointer-events-none"></div>
      
      {/* Main Game Container */}
      <div className="relative w-full max-w-md h-full md:h-[800px] md:border-x-2 border-slate-700 bg-slate-900/90 backdrop-blur-sm shadow-2xl z-10 flex flex-col overflow-hidden">
        
        {/* Header / HUD */}
        <div className="absolute top-0 w-full p-4 flex justify-between items-start z-30 pointer-events-none">
          <div>
            <div className="text-4xl font-bold font-mono tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-cyan-300">
              {score.toString().padStart(6, '0')}
            </div>
            {combo > 1 && (
              <div className="text-xl font-bold text-yellow-300 animate-bounce">
                {combo} COMBO
              </div>
            )}
          </div>
          <div className="flex flex-col items-end gap-2 w-1/3">
             <div className="flex items-center gap-2 w-full justify-end">
                <Heart className="w-5 h-5 text-red-500 fill-red-500" />
                <div className="h-4 w-full bg-slate-800 rounded-full overflow-hidden border border-slate-700">
                  <div 
                    className={`h-full transition-all duration-300 ${health > 50 ? 'bg-green-500' : health > 20 ? 'bg-yellow-500' : 'bg-red-500 animate-pulse'}`}
                    style={{ width: `${health}%` }}
                  />
                </div>
             </div>
          </div>
        </div>

        {/* --- Background Character Display (IP) --- */}
        {gameState === 'PLAYING' && (
          <div className="absolute inset-0 z-0 flex items-center justify-center pointer-events-none opacity-40">
             {/* ★ ここにメインキャラクター（IP）の画像を表示できます ★
                例: <img src="/your-character.png" className="..." />
             */}
             <div className={`transition-transform duration-100 ${characterAction === 'ATTACK' ? 'scale-110 text-yellow-200' : characterAction === 'DAMAGE' ? 'scale-90 text-red-500 translate-x-1' : 'scale-100 text-white'}`}>
                <User size={300} strokeWidth={1} />
             </div>
          </div>
        )}

        {/* Start Menu Overlay */}
        {gameState === 'MENU' && (
          <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/80 backdrop-blur-md">
            <h1 className="text-6xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-fuchsia-500 to-cyan-500 mb-8 drop-shadow-[0_0_15px_rgba(255,255,255,0.5)]">
              RHYTHM<br/>HERO
            </h1>
            <p className="mb-8 text-gray-300 text-center px-4">
              迫りくる敵（ノーツ）を<br/>タイミングよく撃破せよ！<br/>
              <span className="text-sm opacity-70">Keys: D / F / J / K</span>
            </p>
            <button 
              onClick={startGame}
              className="group relative px-8 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-xl rounded-full transition-all hover:scale-105 active:scale-95 shadow-[0_0_20px_rgba(8,145,178,0.6)] flex items-center gap-2 overflow-hidden"
            >
              <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div>
              <Play className="fill-white" /> MISSION START
            </button>
          </div>
        )}

        {/* Result Screen */}
        {gameState === 'GAMEOVER' && (
          <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md animate-in fade-in duration-500">
            <h2 className="text-5xl font-bold text-red-500 mb-2 glitch-text">FAILED</h2>
            <div className="text-2xl text-white mb-6">Score: {score}</div>
            <div className="flex items-center gap-2 text-yellow-400 mb-8">
               <Trophy /> Max Combo: {maxCombo}
            </div>
            <button 
              onClick={startGame}
              className="px-6 py-3 bg-white text-black font-bold rounded-full hover:bg-gray-200 transition flex items-center gap-2"
            >
              <RotateCcw className="w-5 h-5" /> RETRY
            </button>
          </div>
        )}

        {/* Judgement Display (Center) */}
        {gameState === 'PLAYING' && judgeText && (
          <div 
            key={judgeText.id}
            className={`absolute top-1/3 left-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-black italic tracking-widest pointer-events-none z-30 animate-ping-short ${judgeText.color}`}
            style={{ animationDuration: '0.3s' }}
          >
            {judgeText.text}
          </div>
        )}

        {/* Lanes Area */}
        <div className="flex-1 relative flex mx-2 mt-20 mb-32 border-x border-slate-800 bg-gradient-to-b from-transparent to-slate-900/50 overflow-hidden z-10">
          {/* Grid Lines */}
          <div className="absolute top-0 left-0 right-0 h-[1px] bg-cyan-500/20"></div>
          
          {/* 4 Lanes */}
          {Array.from({ length: 4 }).map((_, i) => (
            <div key={i} className="flex-1 relative border-r border-slate-800 last:border-r-0 group">
              <div className="absolute top-2 w-full text-center text-slate-600 font-bold text-xs opacity-50">
                {LANES[i]}
              </div>
              <div 
                className={`absolute bottom-0 w-full transition-all duration-75 ease-out ${
                  activeLanes[i] 
                  ? 'h-full bg-gradient-to-t from-cyan-500/20 to-transparent' 
                  : 'h-0'
                }`}
              />
            </div>
          ))}

          {/* Target Line */}
          <div 
            className="absolute left-0 right-0 h-1 bg-white/50 z-10"
            style={{ top: HIT_Y }}
          ></div>

          {/* Notes Rendering (Characters) */}
          {notesRef.current.map((note) => (
             <div
               key={note.id}
               className={`absolute w-12 h-12 -ml-6 z-20 pointer-events-none flex items-center justify-center transition-transform ${LANE_COLORS[note.lane]}`}
               style={{
                 left: `${note.lane * 25 + 12.5}%`,
                 top: note.y - 24, // Center vertically on Y
                 transform: `scale(${note.y > HIT_Y ? 1.2 : 1})`
               }}
             >
               {/* ★ ここをキャラクター画像に差し替えられます ★
                  例: <img src="/enemy.png" className="w-full h-full object-contain" />
               */}
               <Ghost size={32} className={note.y > HIT_Y ? 'opacity-50' : 'opacity-100'} />
             </div>
          ))}
        </div>

        {/* Input Area (Bottom) */}
        <div className="absolute bottom-0 w-full h-32 flex border-t-4 border-slate-700 bg-slate-800 z-40">
          {LANES.map((key, i) => (
            <button
              key={i}
              className={`flex-1 flex flex-col items-center justify-center border-r border-slate-700 last:border-r-0 active:bg-slate-700 transition-colors focus:outline-none touch-none select-none relative overflow-hidden`}
              onPointerDown={(e) => {
                e.preventDefault(); 
                handleInput(i);
              }}
            >
              <div className={`w-16 h-16 rounded-full border-2 ${activeLanes[i] ? 'border-cyan-400 bg-cyan-400/20 scale-90' : 'border-slate-600'} transition-transform duration-75 flex items-center justify-center`}>
                <span className="text-slate-400 font-bold text-xl">{key}</span>
              </div>
              {activeLanes[i] && (
                 <div className="absolute inset-0 bg-cyan-500/10 animate-pulse"></div>
              )}
            </button>
          ))}
        </div>

      </div>

      <style jsx>{`
        @keyframes ping-short {
          0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        .animate-ping-short {
          animation: ping-short 0.3s cubic-bezier(0, 0, 0.2, 1) forwards;
        }
        .glitch-text {
          text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
          animation: glitch 1s linear infinite;
        }
        @keyframes glitch {
          2%, 64% { transform: translate(2px,0) skew(0deg); }
          4%, 60% { transform: translate(-2px,0) skew(0deg); }
          62% { transform: translate(0,0) skew(5deg); }
        }
      `}</style>
    </div>
  );
}


