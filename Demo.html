<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Behavior Soundscape (Mobile)</title>
  <style>
    /* --- ベーススタイル --- */
    body { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: white; -webkit-tap-highlight-color: transparent; }
    #container { position: relative; width: 100vw; height: 100vh; background: #000; }
    
    /* 映像とエフェクト */
    video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.7; }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }
    #effect_canvas { mix-blend-mode: screen; z-index: 2; }

    /* --- 演出UI --- */
    /* 狐ゲージ */
    #foxGaugeContainer {
      position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
      width: 150px; height: 150px; pointer-events: none; z-index: 25;
      display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.1s;
    }
    #foxGaugeSvg circle { fill: none; stroke-width: 10; stroke-linecap: round; transform: rotate(-90deg); transform-origin: 50% 50%; }
    #foxGaugeBg { stroke: rgba(255, 255, 255, 0.2); }
    #foxGaugeBar { stroke: #ff4400; stroke-dasharray: 440; stroke-dashoffset: 440; transition: stroke-dashoffset 0.05s linear; }
    .fox-label { position: absolute; font-size: 16px; font-weight: 800; color: #ff4400; text-shadow: 0 0 5px black; text-align: center; line-height: 1.2; }

    /* モード表示 */
    #foxIndicator {
      position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%) scale(0);
      font-size: 40px; font-weight: 900; color: #ff4400; text-shadow: 0 0 20px #ffaa00;
      pointer-events: none; z-index: 30; transition: transform 0.4s cubic-bezier(0.17, 0.88, 0.32, 1.27);
      white-space: nowrap; text-align: center; width: 100%;
    }
    #foxIndicator.show { transform: translate(-50%, -50%) scale(1); }
    .sub-text { font-size: 18px; display: block; color: #fff; text-shadow: 0 0 10px #000; }

    /* 応援テキスト */
    .cheer-text {
      position: absolute; font-size: 40px; font-weight: 900; color: #fff;
      text-shadow: 0 0 15px #ff00de, 2px 2px 0px #000;
      pointer-events: none; z-index: 30; animation: popUp 1s forwards; white-space: nowrap;
    }
    @keyframes popUp {
      0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1.0) rotate(0deg); opacity: 1; }
      100% { transform: translate(-50%, -150%) scale(0.8) rotate(5deg); opacity: 0; }
    }

    /* レイテンシ */
    #latencyBox {
      position: absolute; top: 10px; left: 10px; z-index: 20;
      font-family: monospace; font-size: 10px; color: #00ffcc;
      background: rgba(0, 0, 0, 0.6); padding: 2px 5px; border-radius: 4px;
      pointer-events: none;
    }

    /* --- コントロールパネル (スマホ最適化) --- */
    #controlPanel {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      width: 96%; max-width: 800px;
      background: rgba(10, 10, 10, 0.85);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 12px;
      padding: 8px 5px;
      display: flex; flex-wrap: wrap; justify-content: center; align-items: center; 
      gap: 8px; row-gap: 8px;
      z-index: 20; box-shadow: 0 5px 20px rgba(0,0,0,0.6);
    }

    /* 各グループを小さく */
    .control-group { 
      display: flex; flex-direction: column; gap: 2px; align-items: center; 
      min-width: 60px; /* 幅を確保しすぎない */
    }
    .label { font-size: 8px; color: #aaa; letter-spacing: 0.5px; font-weight: 700; margin-bottom: 2px; }

    /* UIパーツ共通 */
    select, button, .mode-opt, input { cursor: pointer; touch-action: manipulation; }

    /* セレクトボックス */
    select {
      background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2);
      padding: 4px; border-radius: 4px; font-size: 10px; outline: none; width: 80px; height: 24px;
    }
    option { background: #222; }

    /* スライダー */
    .slider-wrapper { display: flex; align-items: center; gap: 4px; }
    input[type=range] { -webkit-appearance: none; width: 70px; height: 3px; background: rgba(255,255,255,0.3); border-radius: 2px; outline: none; margin: 0; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #00ffcc; border: 2px solid rgba(0,0,0,0.5); }
    .val-display { font-family: monospace; color: #00ffcc; font-weight: bold; font-size: 10px; width: 15px; text-align: right;}

    /* トグルボタン群 */
    .toggle-group { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; }
    .toggle-btn {
      background: transparent; border: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.8);
      padding: 4px 8px; border-radius: 10px; font-size: 9px; font-weight: bold;
      transition: 0.2s; display: flex; align-items: center; gap: 3px; white-space: nowrap; height: 24px;
    }
    .toggle-btn.active { background: rgba(0, 255, 204, 0.2); border-color: #00ffcc; color: #00ffcc; }
    .indicator { width: 5px; height: 5px; border-radius: 50%; background: #555; }
    .toggle-btn.active .indicator { background: #00ffcc; box-shadow: 0 0 4px #00ffcc; }

    /* モード切替スイッチ */
    #modeSwitch { display: flex; background: rgba(0,0,0,0.5); border-radius: 12px; overflow: hidden; border: 1px solid #444; height: 24px; }
    .mode-opt { padding: 0 10px; display:flex; align-items:center; font-size: 10px; font-weight: bold; color: #888; transition: 0.3s; }
    .mode-opt.active { background: #00ffcc; color: #000; }

    /* スタート画面 */
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 50; backdrop-filter: blur(10px);
      padding: 20px; text-align: center;
    }
    h1 { font-weight: 300; letter-spacing: 2px; font-size: 1.8rem; margin-bottom: 5px; color: #fff; }
    .subtitle { font-size: 0.9rem; color: #00ffcc; margin-bottom: 30px; letter-spacing: 1px; opacity: 0.8; }
    .btn-start { 
      padding: 15px 50px; font-size: 16px; letter-spacing: 2px; font-weight: bold;
      background: linear-gradient(135deg, #00ffcc 0%, #0099ff 100%);
      color: #002233; border: none; border-radius: 50px; 
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
    }
    #cameraSelect { margin-top: 25px; padding: 10px; width: 250px; background: #222; border-color: #444; color:white; font-size:12px; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body>

  <div id="container">
    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="effect_canvas"></canvas>
    
    <div id="foxGaugeContainer">
      <svg id="foxGaugeSvg" width="150" height="150">
        <circle id="foxGaugeBg" cx="75" cy="75" r="70"></circle>
        <circle id="foxGaugeBar" cx="75" cy="75" r="70"></circle>
      </svg>
      <div class="fox-label">DOUBLE<br>FOX<br>HOLD</div>
    </div>

    <div id="foxIndicator">
        FOX MODE<br>
        <span class="sub-text">ON</span>
    </div>
    
    <div id="latencyBox">LATENCY: -- ms</div>

    <div id="controlPanel">
      <div class="control-group">
        <span class="label">TRACKING</span>
        <div id="modeSwitch">
          <div class="mode-opt active" id="btnBody">BODY</div>
          <div class="mode-opt" id="btnHands">HANDS</div>
        </div>
      </div>

      <div class="control-group">
        <span class="label">SOUND</span>
        <select id="soundSelect">
          <option value="crystal">CRYSTAL</option>
          <option value="cyber">CYBER</option>
          <option value="bubble">BUBBLE</option>
        </select>
      </div>

      <div class="control-group">
        <span class="label">SENSITIVITY</span>
        <div class="slider-wrapper">
          <input type="range" id="sensSlider" min="1" max="50" value="25">
          <span id="sensVal" class="val-display">25</span>
        </div>
      </div>

      <div class="control-group" style="flex-grow:1; width:100%;">
        <span class="label">OPTIONS</span>
        <div class="toggle-group">
          <button id="cheerBtn" class="toggle-btn"><div class="indicator"></div> CHEER</button>
          <button id="droneBtn" class="toggle-btn"><div class="indicator"></div> DRONE</button>
          <button id="paintBtn" class="toggle-btn"><div class="indicator"></div> PAINT</button>
          <button id="skelBtn" class="toggle-btn"><div class="indicator"></div> SKEL</button>
        </div>
      </div>
    </div>

    <div id="overlay">
      <h1>BEHAVIOR<br>SOUNDSCAPE</h1>
      <div class="subtitle">Interactive Motion Art</div>
      <button id="startBtn" class="btn-start">START</button>
      <select id="cameraSelect"></select>
    </div>
  </div>

  <script>
    const videoElement = document.getElementById('input_video');
    const effectCanvas = document.getElementById('effect_canvas');
    const effectCtx = effectCanvas.getContext('2d');
    const latencyBox = document.getElementById('latencyBox');
    const overlay = document.getElementById('overlay');
    const cameraSelect = document.getElementById('cameraSelect');
    
    const foxIndicator = document.getElementById('foxIndicator');
    const foxGaugeContainer = document.getElementById('foxGaugeContainer');
    const foxGaugeBar = document.getElementById('foxGaugeBar');
    
    // UI
    const btnBody = document.getElementById('btnBody');
    const btnHands = document.getElementById('btnHands');
    const skelBtn = document.getElementById('skelBtn');
    const paintBtn = document.getElementById('paintBtn');
    const droneBtn = document.getElementById('droneBtn');
    const cheerBtn = document.getElementById('cheerBtn');
    const sensSlider = document.getElementById('sensSlider');
    const sensVal = document.getElementById('sensVal');
    const soundSelect = document.getElementById('soundSelect');

    // 状態
    let trackingMode = 'body'; 
    let showSkeleton = false; 
    let isPaintMode = false;
    let isDroneEnabled = false; 
    let isCheerEnabled = false; 
    let sensitivityThreshold = 25; 
    let currentMode = 'crystal';
    
    // 隠しコマンド・応援
    let isFoxMode = false; 
    let foxState = { active: false, startTime: 0, triggered: false };
    let cheerScore = 0; 
    let lastCheerTime = 0;
    
    let prevPose = { rx:0, ry:0, lx:0, ly:0 };
    let prevFingers = {}; 
    let lastHandNoteTime = 0; 

    function resize() {
      effectCanvas.width = window.innerWidth;
      effectCanvas.height = window.innerHeight;
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // ★ 狐モードをリセットする関数
    function resetFoxMode() {
      if(isFoxMode) {
        isFoxMode = false;
        foxIndicator.classList.add('show');
        foxIndicator.innerHTML = `FOX MODE<br><span class="sub-text">OFF</span>`;
        foxIndicator.style.color = "#00ffcc";
        setTimeout(() => { foxIndicator.classList.remove('show'); }, 1500);
        
        foxState = { active: false, startTime: 0, triggered: false };
        foxGaugeContainer.style.opacity = 0;
      }
    }

    // --- UIイベント ---
    btnBody.addEventListener('click', () => {
      trackingMode = 'body';
      btnBody.classList.add('active'); btnHands.classList.remove('active');
      resetFoxMode(); 
    });
    btnHands.addEventListener('click', () => {
      trackingMode = 'hands';
      btnHands.classList.add('active'); btnBody.classList.remove('active');
      resetFoxMode();
    });

    skelBtn.addEventListener('click', () => { showSkeleton = !showSkeleton; skelBtn.classList.toggle('active', showSkeleton); });
    paintBtn.addEventListener('click', () => { isPaintMode = !isPaintMode; paintBtn.classList.toggle('active', isPaintMode); if(!isPaintMode) effectCtx.clearRect(0,0,effectCanvas.width,effectCanvas.height); });
    droneBtn.addEventListener('click', () => { isDroneEnabled = !isDroneEnabled; droneBtn.classList.toggle('active', isDroneEnabled); if(!isDroneEnabled && drone) drone.volume.rampTo(-Infinity, 0.5); });
    cheerBtn.addEventListener('click', () => { isCheerEnabled = !isCheerEnabled; cheerBtn.classList.toggle('active', isCheerEnabled); });
    sensSlider.addEventListener('input', (e) => { sensitivityThreshold = parseInt(e.target.value); sensVal.innerText = sensitivityThreshold; });
    soundSelect.addEventListener('change', (e) => {
      currentMode = e.target.value; 
      if(isAudioReady) playSound(null, 0.5, true);
      resetFoxMode(); 
    });

    // --- 音響設定 (Tone.js) ---
    let synthCrystal, synthCyber, synthBubble, synthFox, drone, panner;
    let isAudioReady = false;
    
    const scaleCrystal = ["C4", "E4", "G4", "B4", "C5", "E5"];
    const scaleCyber   = ["C3", "Eb3", "F3", "G3", "Bb3", "C4"];
    const scaleBubble  = ["F4", "G4", "A4", "C5", "D5", "F5"];
    const scaleFox     = ["C4", "Eb4", "F4", "G4", "Bb4", "C5"];

    async function initAudio() {
      const reverb = new Tone.Reverb({ decay: 4, wet: 0.5 }).toDestination();
      panner = new Tone.Panner(0).connect(reverb);
      const delay = new Tone.FeedbackDelay("8n", 0.3).connect(panner);

      synthCrystal = new Tone.PolySynth(Tone.FMSynth, { 
        oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 2 }, modulationIndex: 3, volume: -8 
      }).connect(delay);

      synthCyber = new Tone.PolySynth(Tone.Synth, { 
        oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }, volume: -10 
      }).toDestination();
      const cyberFilter = new Tone.AutoFilter("4n").connect(delay).start(); 
      synthCyber.connect(cyberFilter);

      synthBubble = new Tone.PolySynth(Tone.Synth, { 
        oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }, volume: -5 
      }).connect(panner); 

      // 狐モード用 (音量調整 -35db)
      synthFox = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "square" }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.6, release: 1.5 }, 
        volume: -35 
      }).connect(reverb);
      const filter = new Tone.AutoFilter("4n").connect(panner).start();
      synthFox.connect(filter);

      drone = new Tone.Oscillator(130.81, "sine").connect(panner); 
      drone.volume.value = -Infinity;

      await Tone.start(); drone.start(); isAudioReady = true;
    }

    function playSound(noteName, yRatio, force = false) {
      if(!isAudioReady) return;
      let note, synth;
      let currentScale;
      if (isFoxMode) { currentScale = scaleFox; synth = synthFox; }
      else if (currentMode === 'crystal') { currentScale = scaleCrystal; synth = synthCrystal; }
      else if (currentMode === 'cyber') { currentScale = scaleCyber; synth = synthCyber; }
      else if (currentMode === 'bubble') { currentScale = scaleBubble; synth = synthBubble; }

      if (noteName) {
        note = noteName;
      } else {
        const idx = Math.floor((1 - yRatio) * currentScale.length);
        note = currentScale[Math.max(0, Math.min(idx, currentScale.length - 1))];
      }
      synth.triggerAttackRelease(note, "8n");
    }

    function updateHeadPan(noseX) {
      if(!isAudioReady || !panner) return;
      let panVal = (0.5 - noseX) * 2.5; 
      panVal = Math.max(-1, Math.min(1, panVal));
      panner.pan.rampTo(panVal, 0.1);
    }

    // --- 応援ボイス ---
    const cheers = ["Good!", "Great!", "Nice!", "Excellent!", "Amazing!", "Cool!"];
    function triggerCheer(x, y) {
      if (!isCheerEnabled) return;
      const now = Date.now();
      if (now - lastCheerTime < 4000) return; 
      const text = cheers[Math.floor(Math.random() * cheers.length)];
      if (window.speechSynthesis) {
        const ut = new SpeechSynthesisUtterance(text);
        ut.lang = 'en-US'; ut.rate = 1.2; ut.volume = 0.8;
        window.speechSynthesis.speak(ut);
      }
      const div = document.createElement('div');
      div.className = 'cheer-text'; div.innerText = text;
      div.style.left = x + 'px'; div.style.top = y + 'px';
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 1000);
      lastCheerTime = now;
    }

    // --- ビジュアル ---
    const particles = [];
    class Particle {
      constructor(x, y, handSide) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 3; this.vy = (Math.random() - 0.5) * 3 + 1;
        this.size = Math.random() * 5 + 2;
        this.life = isPaintMode ? 2.0 : 1.0;
        this.decay = isPaintMode ? 0.005 : (0.03 + Math.random() * 0.03);
        if (isFoxMode) { this.color = `hsl(${Math.random()*40}, 100%, 60%)`; }
        else {
           if (currentMode === 'crystal') { this.color = handSide === 'right' ? '#00ffff' : '#ffaa00'; }
           else if (currentMode === 'cyber') { this.color = handSide === 'right' ? '#00ff00' : '#ff00aa'; }
           else if (currentMode === 'bubble') { this.color = handSide === 'right' ? '#ffffff' : '#ffb6c1'; }
        }
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= this.decay;
        if(!isPaintMode) this.size *= 0.95;
      }
      draw(ctx) {
        ctx.globalAlpha = Math.max(0, Math.min(1, this.life));
        ctx.fillStyle = this.color;
        ctx.beginPath(); 
        if(currentMode === 'cyber' && !isFoxMode) ctx.rect(this.x, this.y, this.size, this.size);
        else ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    }

    function updateVisuals(w, h) {
      if (isPaintMode) {
          effectCtx.fillStyle = 'rgba(0, 0, 0, 0.03)';
          effectCtx.fillRect(0, 0, w, h);
      } else {
          effectCtx.clearRect(0, 0, w, h);
      }
    }

    // --- ロジック ---
    function detectFoxGesture(landmarks) {
      const indexUp = landmarks[8].y < landmarks[6].y;
      const pinkyUp = landmarks[20].y < landmarks[18].y;
      const middleDown = landmarks[12].y > landmarks[10].y;
      const ringDown = landmarks[16].y > landmarks[14].y;
      return indexUp && pinkyUp && middleDown && ringDown;
    }

    function updateFoxState(isDetected) {
      if (isDetected) {
        if (foxState.triggered) return;
        if (!foxState.active) {
          foxState.active = true;
          foxState.startTime = Date.now();
          foxGaugeContainer.style.opacity = 1;
        } else {
          const elapsed = Date.now() - foxState.startTime;
          // ホールド1秒
          const progress = Math.min(1, elapsed / 1000); 
          const offset = 440 * (1 - progress); // 440 = stroke-dasharray (radius 70 * 2 * PI ≈ 440)
          document.getElementById('foxGaugeBar').style.strokeDashoffset = offset;

          if (progress >= 1) {
             toggleFoxMode();
             foxState.triggered = true; 
             foxState.active = false;
             foxGaugeContainer.style.opacity = 0;
          }
        }
      } else {
        foxState.active = false;
        foxState.triggered = false;
        foxGaugeContainer.style.opacity = 0;
        document.getElementById('foxGaugeBar').style.strokeDashoffset = 440;
      }
    }

    function toggleFoxMode() {
      isFoxMode = !isFoxMode;
      foxIndicator.classList.add('show');
      foxIndicator.innerHTML = isFoxMode ? `FOX MODE<br><span class="sub-text">ON</span>` : `FOX MODE<