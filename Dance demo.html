<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Sonic Dancer (Layout Fixed)</title>
  <style>
    /* --- „Éô„Éº„ÇπË®≠ÂÆö --- */
    body { margin: 0; padding: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: white; cursor: none; }
    body.user-active { cursor: default; }
    
    #container { 
        position: relative; width: 100vw; height: 100vh; 
        display: flex; justify-content: center; align-items: center;
        background: #000;
    }
    
    #visualWrapper { 
        position: relative; width: 100%; height: 100%; 
        display: flex; justify-content: center; align-items: center;
        transform: scaleX(1); transition: transform 0.3s ease; 
    }
    #visualWrapper.mirror { transform: scaleX(-1); }

    video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; opacity: 0.6; }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
    #effect_canvas { mix-blend-mode: screen; z-index: 2; }

    #latencyBox { 
        position: absolute; top: 20px; left: 20px; z-index: 20; 
        font-family: monospace; font-size: 12px; color: #00ffcc; 
        background: rgba(0, 0, 0, 0.7); padding: 6px 12px; border-radius: 4px; 
        pointer-events: none; transition: opacity 0.5s; 
        border-left: 3px solid #00ffcc;
    }

    /* --- „Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ („Ç∞„É™„ÉÉ„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà) --- */
    #controlPanel {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      width: 96%; max-width: 1000px;
      background: rgba(20, 25, 30, 0.95); backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 12px; padding: 15px;
      display: flex; flex-direction: column; gap: 10px; /* ‰∏äÊÆµ„Å®‰∏ãÊÆµ„ÅÆÈñìÈöî */
      z-index: 20; box-shadow: 0 10px 40px rgba(0,0,0,0.6); transition: opacity 0.5s;
    }
    #controlPanel.fade-out { opacity: 0; pointer-events: none; }
    #latencyBox.fade-out { opacity: 0; }

    /* ‰∏äÊÆµ: Ë®≠ÂÆö„Éú„Çø„É≥Áæ§ */
    .top-row {
        display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;
        border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;
    }

    /* ‰∏ãÊÆµ: „Çπ„É©„Ç§„ÉÄ„ÉºÁæ§ (3„Ç´„É©„É†Âõ∫ÂÆö) */
    .bottom-row {
        display: grid; 
        grid-template-columns: 1fr 1fr 1fr; /* 3Á≠âÂàÜ */
        gap: 15px;
        align-items: start;
    }

    .control-group { 
        display: flex; flex-direction: column; align-items: center; 
    }
    
    .label { font-size: 9px; color: #888; letter-spacing: 1px; font-weight: 700; margin-bottom: 4px; text-transform: uppercase; }
    
    .btn-group { display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; }

    .toggle-btn {
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #eee;
      padding: 6px 12px; border-radius: 4px; font-size: 11px; font-weight: bold;
      transition: 0.2s; display: flex; align-items: center; gap: 6px; white-space: nowrap; cursor: pointer;
    }
    .toggle-btn:hover { background: rgba(255,255,255,0.25); }
    .toggle-btn.active { background: #ffaa00; border-color: #ffaa00; color: #000; box-shadow: 0 0 15px rgba(255,170,0,0.4); }
    .indicator { width: 6px; height: 6px; border-radius: 50%; background: #555; }
    .toggle-btn.active .indicator { background: #fff; }

    #focusBtn.active { background: #ff3366; border-color: #ff3366; color:#fff; }
    #autoBtn.active { background: #00ffcc; border-color: #00ffcc; color:#000; }
    #autoBtn.active .indicator { background: #000; }
    #modelBtn.active { background: #cc00ff; border-color: #cc00ff; color:#fff; }
    .preset-btn { min-width: 60px; justify-content: center; }
    .preset-btn.active { background: #00ccff; border-color: #00ccff; color: #000; }

    /* „Çπ„É©„Ç§„ÉÄ„Éº„Ç®„É™„Ç¢„ÅÆÊï¥ÂΩ¢ */
    .slider-row { display: flex; align-items: center; width: 100%; height: 24px; }
    .sub-label { 
        font-size: 10px; color: #aaa; width: 35px; text-align: right; margin-right: 8px; font-weight: bold; 
    }
    .slider-wrapper { display: flex; align-items: center; flex-grow: 1; }
    
    input[type=range] { -webkit-appearance: none; width: 100%; height: 4px; background: #444; border-radius: 2px; outline: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #ccc; cursor: pointer; transition: 0.1s; border:2px solid #333; }
    
    .theme-hand input[type=range]::-webkit-slider-thumb { background: #00ccff; }
    .theme-foot input[type=range]::-webkit-slider-thumb { background: #ffaa00; }
    .theme-stop input[type=range]::-webkit-slider-thumb { background: #ffff00; }

    .val-display { font-family: monospace; color: #fff; font-weight: bold; font-size: 11px; width: 25px; text-align: right;}

    /* „É°„Éº„Çø„Éº */
    .meter-box { width: 100%; height: 4px; background: #222; margin: 4px 0; position: relative; border-radius: 2px; overflow: hidden; }
    .meter-bar { height: 100%; width: 0%; background: #555; transition: width 0.05s linear; }
    .meter-thresh { position: absolute; top: 0; bottom: 0; width: 2px; background: #fff; z-index: 2; left: 0%; transition: left 0.3s ease; }
    
    .theme-hand .meter-bar { background: #00ccff; }
    .theme-foot .meter-bar { background: #ffaa00; }
    .theme-stop .meter-bar { background: #ffff00; }

    /* „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú: ÁîªÈù¢„ÅåÁã≠„ÅÑ„Å®„Åç„ÅØÁ∏¶‰∏¶„Å≥ */
    @media (max-width: 700px) {
        .bottom-row { grid-template-columns: 1fr; gap: 20px; }
    }

    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5,5,10,0.92); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 50; backdrop-filter: blur(10px);
    }
    h1 { font-weight: 900; letter-spacing: 4px; font-size: 3.5rem; margin-bottom: 5px; color: #ffaa00; text-transform: uppercase; font-style: italic; text-shadow: 0 0 30px #ff6600; }
    .subtitle { font-size: 1.2rem; color: #aaa; margin-bottom: 40px; letter-spacing: 2px; }
    .btn-start { 
      padding: 18px 70px; font-size: 16px; letter-spacing: 2px; font-weight: bold;
      background: linear-gradient(45deg, #ffaa00, #ffcc33); color: #000; border: none; border-radius: 40px; 
      box-shadow: 0 0 30px rgba(255, 170, 0, 0.4); cursor: pointer; transition: 0.3s;
      pointer-events: auto;
    }
    .btn-start:hover { box-shadow: 0 0 60px rgba(255, 170, 0, 0.8); transform: scale(1.05); }
    .btn-start:disabled { background: #333; color: #777; cursor: wait; box-shadow: none; transform: none; }
  </style>

  <script src="https://unpkg.com/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
</head>
<body>

  <div id="container">
    <div id="visualWrapper">
        <video id="input_video" autoplay playsinline muted loop></video>
        <canvas id="effect_canvas"></canvas>
    </div>
    <input type="file" id="fileInput" accept="video/*" style="display:none;">
    
    <div id="latencyBox">LATENCY: -- ms (Layout Fix)</div>

    <div id="controlPanel">
      
      <div class="top-row">
        <div class="control-group">
            <span class="label">PRESET</span>
            <div class="btn-group">
                <button id="presetFinger" class="toggle-btn preset-btn">üéÆ FINGER</button>
                <button id="presetBody" class="toggle-btn preset-btn active">üíÉ BODY</button>
                <button id="presetDance" class="toggle-btn preset-btn">üî• DANCE</button>
                <button id="autoBtn" class="toggle-btn" style="margin-left:5px;"><div class="indicator"></div> ‚ö° AUTO</button>
            </div>
        </div>

        <div class="control-group">
            <span class="label">INPUT / MODEL</span>
            <div class="btn-group">
               <button id="camBtn" class="toggle-btn">üì∑</button>
               <button id="captureBtn" class="toggle-btn active">üì∫</button>
               <button id="uploadBtn" class="toggle-btn">üìÇ</button>
               <div style="width:1px; background:#555; margin:0 5px;"></div>
               <button id="focusBtn" class="toggle-btn"><div class="indicator"></div> üîç</button>
               <button id="modelBtn" class="toggle-btn active"><div class="indicator"></div> üß† FULL</button>
            </div>
        </div>

        <div class="control-group">
            <span class="label">TOOLS</span>
            <div class="btn-group">
                <button id="calibBtn" class="toggle-btn">üéØ RESET</button>
                <button id="mirrorBtn" class="toggle-btn">‚Üî MIRROR</button>
                <button id="skelBtn" class="toggle-btn active">üíÄ SKEL</button>
            </div>
        </div>
      </div>

      <div class="bottom-row">
          
          <div class="control-group theme-hand" style="width:100%;">
            <span class="label" style="color:#00ccff; width:100%; text-align:center; border-bottom:1px solid #333; padding-bottom:2px; margin-bottom:5px;">üñêÔ∏è HANDS</span>
            <div class="slider-row">
              <span class="sub-label">SENS</span>
              <div class="slider-wrapper"><input type="range" id="handSensSlider" min="10" max="150" value="80"></div>
              <span id="handSensVal" class="val-display" style="color:#00ccff;">80</span>
            </div>
            <div class="meter-box"><div id="handMeter" class="meter-bar"></div><div id="handThresh" class="meter-thresh"></div></div>
            <div class="slider-row">
              <span class="sub-label">VOL</span>
              <div class="slider-wrapper"><input type="range" id="motionVolSlider" min="0" max="100" value="70"></div>
              <span class="val-display">70</span>
            </div>
          </div>

          <div class="control-group theme-foot" style="width:100%;">
            <span class="label" style="color:#ffaa00; width:100%; text-align:center; border-bottom:1px solid #333; padding-bottom:2px; margin-bottom:5px;">ü¶∂ FEET</span>
            <div class="slider-row">
              <span class="sub-label">SENS</span>
              <div class="slider-wrapper"><input type="range" id="footSensSlider" min="1" max="50" value="20"></div>
              <span id="footSensVal" class="val-display" style="color:#ffaa00;">20</span>
            </div>
            <div class="meter-box"><div id="footMeter" class="meter-bar"></div><div id="footThresh" class="meter-thresh"></div></div>
            <div class="slider-row">
              <span class="sub-label">VOL</span>
              <div class="slider-wrapper"><input type="range" id="tapVolSlider" min="0" max="100" value="80"></div>
              <span class="val-display">80</span>
            </div>
          </div>

          <div class="control-group theme-stop" style="width:100%;">
            <span class="label" style="color:#ffff00; width:100%; text-align:center; border-bottom:1px solid #333; padding-bottom:2px; margin-bottom:5px;">üõë STOP</span>
            <div class="slider-row">
              <span class="sub-label">SENS</span>
              <div class="slider-wrapper"><input type="range" id="stopSensSlider" min="10" max="100" value="50"></div>
              <span id="stopSensVal" class="val-display" style="color:#ffff00;">50</span>
            </div>
            <div class="meter-box"><div id="stopMeter" class="meter-bar"></div><div id="stopThresh" class="meter-thresh"></div></div>
            <div class="slider-row">
              <span class="sub-label">VOL</span>
              <div class="slider-wrapper"><input type="range" id="poseVolSlider" min="0" max="100" value="80"></div>
              <span class="val-display">80</span>
            </div>
          </div>

      </div>
    </div>

    <div id="overlay">
      <h1>SONIC<br>DANCER</h1>
      <div class="subtitle">DEMO 25: Layout Fix</div>
      <button id="startBtn" disabled>Loading AI...</button>
      <select id="cameraSelect" style="margin-top:20px; width:200px; display:none;"></select>
    </div>
  </div>

  <script>
    let uiTimeout;
    const body = document.body;
    const controlPanel = document.getElementById('controlPanel');
    const latencyBox = document.getElementById('latencyBox');

    function resetUiTimer() {
      body.classList.add('user-active');
      controlPanel.classList.remove('fade-out');
      latencyBox.classList.remove('fade-out');
      body.style.cursor = 'default';
      clearTimeout(uiTimeout);
      uiTimeout = setTimeout(() => {
        controlPanel.classList.add('fade-out');
        latencyBox.classList.add('fade-out');
        body.style.cursor = 'none';
      }, 3000);
    }
    window.addEventListener('mousemove', resetUiTimer);
    window.addEventListener('click', resetUiTimer);
    window.addEventListener('touchstart', resetUiTimer);

    window.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('startBtn');
        setTimeout(() => {
            if(btn.disabled) {
                btn.innerText = "Check Network";
                btn.style.background = "#555";
            }
        }, 20000);
    });

    window.addEventListener('load', () => {
        const btn = document.getElementById('startBtn');
        btn.innerText = "START EXPERIENCE";
        btn.disabled = false;
        initApp(); 
        resetUiTimer();
    });

    function initApp() {
        const videoElement = document.getElementById('input_video');
        const effectCanvas = document.getElementById('effect_canvas');
        const effectCtx = effectCanvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const cameraSelect = document.getElementById('cameraSelect');
        const visualWrapper = document.getElementById('visualWrapper');
        
        const camBtn = document.getElementById('camBtn');
        const captureBtn = document.getElementById('captureBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        
        const calibBtn = document.getElementById('calibBtn');
        const mirrorBtn = document.getElementById('mirrorBtn');
        const focusBtn = document.getElementById('focusBtn');
        const skelBtn = document.getElementById('skelBtn');
        const autoBtn = document.getElementById('autoBtn');
        const modelBtn = document.getElementById('modelBtn'); 
        
        const presetFinger = document.getElementById('presetFinger');
        const presetBody = document.getElementById('presetBody');
        const presetDance = document.getElementById('presetDance');

        const workCanvas = document.createElement('canvas');
        workCanvas.width = 320;
        workCanvas.height = 240;
        const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
        
        const handSensSlider = document.getElementById('handSensSlider');
        const handSensVal = document.getElementById('handSensVal');
        const handMeter = document.getElementById('handMeter');
        const handThresh = document.getElementById('handThresh');
        const handVolSlider = document.getElementById('handVolSlider');
        const handVolVal = document.getElementById('handVolVal');

        const footSensSlider = document.getElementById('footSensSlider');
        const footSensVal = document.getElementById('footSensVal');
        const footMeter = document.getElementById('footMeter');
        const footThresh = document.getElementById('footThresh');
        const footVolSlider = document.getElementById('footVolSlider');
        const footVolVal = document.getElementById('footVolVal');

        const stopSensSlider = document.getElementById('stopSensSlider');
        const stopSensVal = document.getElementById('stopSensVal');
        const stopMeter = document.getElementById('stopMeter');
        const stopThresh = document.getElementById('stopThresh');
        const stopVolSlider = document.getElementById('stopVolSlider');
        const stopVolVal = document.getElementById('stopVolVal');
        
        let isProcessing = false;
        let isModelChanging = false; 
        let isMirrored = false;
        let isFocusMode = false;
        let isAutoSens = false;
        let showSkeleton = true;
        let isFullModel = true; 
        
        let handThreshold = 80;
        let footThreshold = 20; 
        let stopThreshold = 50; 

        let peakHandSpeed = 50;
        let peakFootSpeed = 20;
        const DECAY_RATE = 0.99;

        let motionMaxDb = 0.7; 
        let tapMaxDb = 0.8; 
        let poseMaxDb = 0.8; 
        
        let calibOffset = { x: 0, y: 0 }; 
        let tempPoseX = 0.5, tempPoseY = 0.5;
        
        let prevPose = {
            rWrist: {x:0, y:0}, lWrist: {x:0, y:0},
            rAnkle: {x:0, y:0}, lAnkle: {x:0, y:0},
            rHandSpeed: 0, lHandSpeed: 0,
            rFootSpeed: 0, lFootSpeed: 0
        };

        let lastRightTap = 0;
        let lastLeftTap = 0;
        let lastTriggerTime = 0; 
        const MAX_PARTICLES = 50; 

        // --- Native Audio ---
        let audioCtx;
        let buffers = {};
        let isAudioReady = false;

        function createBuffer(type) {
            if(!audioCtx) return null;
            const sr = audioCtx.sampleRate;
            let dur = 1.0;
            if(type === 'rim') dur = 0.1;
            if(type === 'clap') dur = 0.3;
            const buf = audioCtx.createBuffer(1, sr * dur, sr);
            const data = buf.getChannelData(0);
            for(let i=0; i<data.length; i++) {
                const t = i/sr;
                if(type === 'marimba') {
                    const env = Math.exp(-t * 6);
                    const attack = Math.exp(-t * 50);
                    data[i] = (Math.sin(t*440*Math.PI*2)*0.6) * env; 
                    data[i] += (Math.random()*0.5-0.25) * attack;
                } else if(type === 'rim') {
                    const env = Math.exp(-t * 30);
                    const f = 800; 
                    let tone = Math.sin(t*f*Math.PI*2);
                    if(tone>0) tone=0.8; else tone=-0.8; 
                    data[i] = tone * env * 0.5 + (Math.random()*2-1) * env * 0.5;
                } else if(type === 'clap') {
                    const noise = Math.random() * 2 - 1;
                    const env = Math.exp(-t * 15);
                    data[i] = noise * env;
                }
            }
            return buf;
        }

        function playSound(buffer, volume, rate = 1.0) {
            if(!audioCtx || !buffer || volume <= 0.01) return;
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            src.playbackRate.value = rate;
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            src.connect(gain);
            gain.connect(audioCtx.destination);
            src.start(0);
        }

        async function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                buffers.bell = createBuffer('marimba');
                buffers.kick = createBuffer('rim');
                buffers.clap = createBuffer('clap');
                isAudioReady = true;
                if(audioCtx.state === 'suspended') await audioCtx.resume();
            } catch(e) { console.error(e); }
        }

        // --- Logic ---
        let lastHandPlay = 0;

        function updateAutoSensitivity(currentHand, currentFoot) {
            if(!isAutoSens) return;
            peakHandSpeed = Math.max(peakHandSpeed * DECAY_RATE, currentHand);
            peakFootSpeed = Math.max(peakFootSpeed * DECAY_RATE, currentFoot);
            if(peakHandSpeed < 30) peakHandSpeed = 30;
            if(peakFootSpeed < 10) peakFootSpeed = 10;

            const targetHand = Math.floor(peakHandSpeed * 0.4);
            const targetFoot = Math.floor(peakFootSpeed * 0.6);
            const targetStop = Math.floor(peakHandSpeed * 0.3 + 20);

            handThreshold = Math.floor(handThreshold * 0.9 + targetHand * 0.1);
            footThreshold = Math.floor(footThreshold * 0.9 + targetFoot * 0.1);
            stopThreshold = Math.floor(stopThreshold * 0.9 + targetStop * 0.1);

            handSensSlider.value = handThreshold; handSensVal.innerText = handThreshold;
            footSensSlider.value = footThreshold; footSensVal.innerText = footThreshold;
            stopSensSlider.value = stopThreshold; stopSensVal.innerText = stopThreshold;
        }

        function updateAudio(speeds) {
            const { rHand, lHand, rFoot, lFoot } = speeds;
            const totalHandSpeed = rHand + lHand;
            const maxFoot = Math.max(rFoot, lFoot);
            const totalBodySpeed = totalHandSpeed + rFoot + lFoot;

            updateAutoSensitivity(totalHandSpeed, maxFoot);

            if(handMeter) {
                handThresh.style.left = `${Math.min(100, (handThreshold / 200) * 100)}%`;
                handMeter.style.width = `${Math.min(100, (totalHandSpeed / 200) * 100)}%`;
                handMeter.style.background = (totalHandSpeed > handThreshold) ? "#fff" : "#00ccff";
            }
            if(footMeter) {
                footThresh.style.left = `${Math.min(100, (footThreshold / 60) * 100)}%`;
                footMeter.style.width = `${Math.min(100, (maxFoot / 60) * 100)}%`;
                footMeter.style.background = (maxFoot > footThreshold) ? "#fff" : "#ffaa00";
            }
            if(stopMeter) {
                stopThresh.style.left = `${Math.min(100, (stopThreshold / 150) * 100)}%`;
                stopMeter.style.width = `${Math.min(100, (totalBodySpeed / 150) * 100)}%`;
                stopMeter.style.background = (totalBodySpeed > stopThreshold) ? "#fff" : "#ffff00";
            }

            if(!isAudioReady) return;
            const now = Date.now();

            if (motionMaxDb > 0 && totalHandSpeed > handThreshold) {
                 if(now - lastHandPlay > 120) { 
                     const scale = [1.0, 1.12, 1.26, 1.5, 1.68]; 
                     const idx = Math.floor(Math.random() * scale.length);
                     playSound(buffers.bell, motionMaxDb, scale[idx]);
                     lastHandPlay = now;
                 }
            }

            if (tapMaxDb > 0) {
                if (rFoot > footThreshold && now - lastRightTap > 150) { 
                    playSound(buffers.kick, tapMaxDb);
                    createBurst(prevPose.rAnkle.x, prevPose.rAnkle.y, 'tap');
                    lastRightTap = now;
                }
                if (lFoot > footThreshold && now - lastLeftTap > 150) {
                    playSound(buffers.kick, tapMaxDb);
                    createBurst(prevPose.lAnkle.x, prevPose.lAnkle.y, 'tap');
                    lastLeftTap = now;
                }
            }

            detectPose(totalBodySpeed, prevPose.rHandSpeed + prevPose.lHandSpeed + prevPose.rFootSpeed + prevPose.lFootSpeed);
        }

        function detectPose(currentTotal, previousTotal) {
             const STOP_LOW = 10.0; 
             const MOVE_HIGH = stopThreshold; 
             const now = Date.now();

             if (now - lastTriggerTime < 120) return; 

             if (previousTotal > MOVE_HIGH && currentTotal < STOP_LOW) {
                 if (poseMaxDb > 0) playSound(buffers.clap, poseMaxDb);
                 createBurst(prevPose.rWrist.x, prevPose.rWrist.y, 'burst'); 
                 createBurst(prevPose.lWrist.x, prevPose.lWrist.y, 'burst');
                 lastTriggerTime = now;
             }
        }

        // --- Visuals ---
        const particles = [];
        class Particle {
          constructor(x, y, type) { 
            this.x = x; this.y = y; this.type = type; 
            if(type === 'hand') {
                this.vx = (Math.random()-0.5)*1; this.vy = (Math.random()-0.5)*1; 
                this.size = Math.random()*3+1; 
                this.color = `hsl(${Math.random()*40 + 180}, 100%, 80%)`; 
                this.decay = 0.15; 
            } else if (type === 'tap') {
                this.vx = (Math.random()-0.5)*8; this.vy = (Math.random()-1.0)*8; 
                this.size = Math.random()*4+2; 
                this.color = '#ffcc00'; 
                this.decay = 0.25; 
            } else { 
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 20 + 5; 
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                this.size = Math.random()*10+5; 
                this.color = '#fff';
                this.decay = 0.08;
            }
            this.life = 1.0;
          }
          update() {
            this.x += this.vx; this.y += this.vy; this.life -= this.decay;
            if(this.type === 'tap') this.vy += 0.4; 
          }
          draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life;
            ctx.beginPath(); 
            if (this.type === 'tap') ctx.rect(this.x, this.y, this.size, this.size); 
            else ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); 
            ctx.fill();
            ctx.globalAlpha = 1.0;
          }
        }
        
        function createBurst(x, y, type) {
            if (particles.length > MAX_PARTICLES) return;
            const count = (type === 'tap' ? 8 : 10);
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, type));
        }

        function renderParticles() {
            effectCtx.globalCompositeOperation = 'lighter';
            for(let i=0; i<particles.length; i++){
                particles[i].update(); particles[i].draw(effectCtx);
                if(particles[i].life<=0){ particles.splice(i,1); i--; }
            }
            if(particles.length > MAX_PARTICLES + 50) particles.splice(0, 50);
            effectCtx.globalCompositeOperation = 'source-over';
        }

        function getCalibratedPoint(point, w, h) {
             let cx = point.x - calibOffset.x; let cy = point.y - calibOffset.y;
             return { x: cx * w, y: cy * h };
        }

        function onPoseResults(results) {
          const w = effectCanvas.width; const h = effectCanvas.height;
          effectCtx.clearRect(0, 0, w, h);

          if (results.poseLandmarks) {
            if (showSkeleton) {
                drawConnectors(effectCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: 'rgba(255,255,255,0.2)', lineWidth: 1});
            }

            const p = results.poseLandmarks;
            tempPoseX = p[0].x; tempPoseY = p[0].y; 

            const rw = getCalibratedPoint(results.poseLandmarks[16], w, h); 
            const lw = getCalibratedPoint(results.poseLandmarks[15], w, h);
            const rf = getCalibratedPoint(results.poseLandmarks[28], w, h); 
            const lf = getCalibratedPoint(results.poseLandmarks[27], w, h); 

            const rHandSpeed = Math.hypot(rw.x - prevPose.rWrist.x, rw.y - prevPose.rWrist.y);
            const lHandSpeed = Math.hypot(lw.x - prevPose.lWrist.x, lw.y - prevPose.lWrist.y);
            const rFootSpeed = Math.hypot(rf.x - prevPose.rAnkle.x, rf.y - prevPose.rAnkle.y);
            const lFootSpeed = Math.hypot(lf.x - prevPose.lAnkle.x, lf.y - prevPose.lAnkle.y);

            updateAudio({rHand: rHandSpeed, lHand: lHandSpeed, rFoot: rFootSpeed, lFoot: lFootSpeed});

            if (rHandSpeed > 10) particles.push(new Particle(rw.x, rw.y, 'hand'));
            if (lHandSpeed > 10) particles.push(new Particle(lw.x, lw.y, 'hand'));

            prevPose = {
                rWrist: rw, lWrist: lw, rAnkle: rf, lAnkle: lf,
                rHandSpeed, lHandSpeed, rFootSpeed, lFootSpeed
            };
          }
          renderParticles();
        }

        const pose = new Pose({locateFile: (file) => `https://unpkg.com/@mediapipe/pose/${file}`});
        pose.setOptions({
            modelComplexity: 2, 
            smoothLandmarks: true, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5
        });
        pose.onResults(onPoseResults);

        // --- Listeners ---
        modelBtn.addEventListener('click', async () => {
            if(isModelChanging) return;
            isModelChanging = true;
            
            // ÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„Å´‰∏ÄÂ∫¶„Éì„Éá„Ç™„ÇíÂÅúÊ≠¢„Åó„Å¶Ë≤†Ëç∑„Çí‰∏ã„Åí„Çã
            videoElement.pause();
            
            isFullModel = !isFullModel;
            const complexity = isFullModel ? 2 : 0;
            const name = isFullModel ? "FULL" : "LITE";
            
            modelBtn.innerHTML = "<div class='indicator'></div> ‚è≥ ...";
            
            // UIÊõ¥Êñ∞„ÅÆ„Åü„ÇÅ„ÅÆÂæÆÂ∞è„Å™ÈÅÖÂª∂ + ÈùûÂêåÊúüÂá¶ÁêÜ
            setTimeout(async () => {
                try {
                    await pose.setOptions({
                        modelComplexity: complexity,
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5
                    });
                    modelBtn.innerHTML = `<div class='indicator'></div> üß† ${name}`;
                    modelBtn.classList.toggle('active', isFullModel);
                    latencyBox.innerText = `LATENCY: ${isFullModel ? "Studio Accuracy" : "Lite Speed"}`;
                } catch(e) {
                    console.error("Model switch error", e);
                    modelBtn.innerHTML = `<div class='indicator'></div> ‚ö†Ô∏è ERROR`;
                } finally {
                    isModelChanging = false;
                    videoElement.play(); // ÂÜçÈñã
                }
            }, 50); 
        });

        function setPreset(mode) {
            [presetFinger, presetBody, presetDance].forEach(b => b.classList.remove('active'));
            if(mode === 'finger') {
                presetFinger.classList.add('active');
                handThreshold = 30; footThreshold = 10; stopThreshold = 30;
            } else if(mode === 'body') {
                presetBody.classList.add('active');
                handThreshold = 80; footThreshold = 20; stopThreshold = 50;
            } else if(mode === 'dance') {
                presetDance.classList.add('active');
                handThreshold = 150; footThreshold = 40; stopThreshold = 100;
            }
            if(isAutoSens) { isAutoSens = false; autoBtn.classList.remove('active'); }
            handSensSlider.value = handThreshold; handSensVal.innerText = handThreshold;
            footSensSlider.value = footThreshold; footSensVal.innerText = footThreshold;
            stopSensSlider.value = stopThreshold; stopSensVal.innerText = stopThreshold;
        }

        presetFinger.addEventListener('click', () => setPreset('finger'));
        presetBody.addEventListener('click', () => setPreset('body'));
        presetDance.addEventListener('click', () => setPreset('dance'));

        autoBtn.addEventListener('click', () => {
            isAutoSens = !isAutoSens;
            autoBtn.classList.toggle('active', isAutoSens);
            if(isAutoSens) { 
                [presetFinger, presetBody, presetDance].forEach(b => b.classList.remove('active'));
                peakHandSpeed = 50; peakFootSpeed = 20; 
            }
        });

        handSensSlider.addEventListener('input', (e) => { 
            handThreshold = parseInt(e.target.value); 
            handSensVal.innerText = handThreshold; 
            if(isAutoSens) { isAutoSens = false; autoBtn.classList.remove('active'); }
        });
        footSensSlider.addEventListener('input', (e) => { 
            footThreshold = parseInt(e.target.value); 
            footSensVal.innerText = footThreshold;
            if(isAutoSens) { isAutoSens = false; autoBtn.classList.remove('active'); }
        });
        stopSensSlider.addEventListener('input', (e) => { 
            stopThreshold = parseInt(e.target.value); 
            stopSensVal.innerText = stopThreshold;
            if(isAutoSens) { isAutoSens = false; autoBtn.classList.remove('active'); }
        });

        motionVolSlider.addEventListener('input', (e) => { 
             motionMaxDb = parseInt(e.target.value)/100;
             handVolVal.innerText = e.target.value;
        });

        tapVolSlider.addEventListener('input', (e) => { 
             tapMaxDb = parseInt(e.target.value)/100;
             footVolVal.innerText = e.target.value;
        });

        poseVolSlider.addEventListener('input', (e) => { 
             poseMaxDb = parseInt(e.target.value)/100;
             stopVolVal.innerText = e.target.value;
        });

        calibBtn.addEventListener('click', () => {
            calibOffset.x = tempPoseX - 0.5; calibOffset.y = tempPoseY - 0.5;
            calibBtn.innerText = "OK!"; setTimeout(() => { calibBtn.innerText = "üéØ RESET POS"; }, 1000);
        });
        mirrorBtn.addEventListener('click', () => {
            isMirrored = !isMirrored;
            if(isMirrored) { visualWrapper.classList.add('mirror'); mirrorBtn.classList.add('active'); } 
            else { visualWrapper.classList.remove('mirror'); mirrorBtn.classList.remove('active'); }
        });
        skelBtn.addEventListener('click', () => { 
            showSkeleton = !showSkeleton; skelBtn.classList.toggle('active', showSkeleton); 
        });
        
        focusBtn.addEventListener('click', () => { 
            isFocusMode = !isFocusMode;
            focusBtn.classList.toggle('active', isFocusMode);
        });

        function setActiveSourceBtn(btnId) {
            [camBtn, captureBtn, uploadBtn].forEach(b => b.classList.remove('active'));
            document.getElementById(btnId).classList.add('active');
        }
        function setMirrorState(shouldMirror) {
            isMirrored = shouldMirror;
            if(isMirrored) { visualWrapper.classList.add('mirror'); mirrorBtn.classList.add('active'); } 
            else { visualWrapper.classList.remove('mirror'); mirrorBtn.classList.remove('active'); }
        }

        let isCameraSetup = false;
        async function setupCameraDevices() {
          try {
            await navigator.mediaDevices.getUserMedia({video:true});
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videos = devices.filter(d => d.kind === 'videoinput');
            cameraSelect.innerHTML = "";
            videos.forEach(v => { const opt = document.createElement('option'); opt.value = v.deviceId; opt.text = v.label || "Camera"; cameraSelect.appendChild(opt); });
            cameraSelect.style.display = "block"; 
            isCameraSetup = true;
          } catch(e){ console.error("Camera perm denied"); }
        }

        camBtn.addEventListener('click', async () => {
            setActiveSourceBtn('camBtn');
            if(!isCameraSetup) await setupCameraDevices(); 
            await startCamera(cameraSelect.value);
            setMirrorState(true); 
        });

        uploadBtn.addEventListener('click', () => { fileInput.click(); });
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                if(videoElement.srcObject) { videoElement.srcObject.getTracks().forEach(t => t.stop()); videoElement.srcObject = null; }
                videoElement.src = url; videoElement.loop = true; videoElement.play();
                setActiveSourceBtn('uploadBtn');
                setMirrorState(false);
            }
        });

        async function startCapture() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                if(videoElement.srcObject) { videoElement.srcObject.getTracks().forEach(t => t.stop()); }
                videoElement.src = "";
                videoElement.srcObject = stream;
                videoElement.play();
                setActiveSourceBtn('captureBtn');
                setMirrorState(false);
            } catch(e) { console.log("Capture Cancelled"); }
        }
        captureBtn.addEventListener('click', startCapture);

        async function startCamera(deviceId) {
          if(videoElement.srcObject) { videoElement.srcObject.getTracks().forEach(t => t.stop()); }
          videoElement.src = "";
          const stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: deviceId ? { exact: deviceId } : undefined, width: 320, height: 240 } });
          videoElement.srcObject = stream;
          videoElement.play();
        }

        function resize() {
            effectCanvas.width = window.innerWidth;
            effectCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        async function globalAiLoop() {
           // ‚òÖ„Éï„É™„Éº„Ç∫ÂØæÁ≠ñ: „Éï„É©„Ç∞‰∏≠„ÅØ„É´„Éº„Éó„Çπ„Ç≠„ÉÉ„Éó
           if(isModelChanging) {
               requestAnimationFrame(globalAiLoop);
               return;
           }

           if(videoElement.readyState >= 2 && !videoElement.paused && !isProcessing) {
               isProcessing = true;
               
               if (isFocusMode) {
                   const vw = videoElement.videoWidth;
                   const vh = videoElement.videoHeight;
                   const cw = vw * 0.6; 
                   const cx = vw * 0.2;
                   workCtx.drawImage(videoElement, cx, 0, cw, vh, 0, 0, workCanvas.width, workCanvas.height);
               } else {
                   workCtx.drawImage(videoElement, 0, 0, workCanvas.width, workCanvas.height);
               }

               try { await pose.send({image: workCanvas}); } catch(e) {}
               isProcessing = false;
           }
           requestAnimationFrame(globalAiLoop);
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
          overlay.style.display = 'none';
          await initAudio();
          await startCapture();
          globalAiLoop();
        });
    }
  </script>
</body>
</html>